<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>从内存加载dll</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>从内存加载dll</h1><br/><br />手动实现dll加载过程，不使用loadLibrary函数<br /><br /><br /><br />main.cpp<br /><div class="codebox"><div class="codebox">#define&nbsp;_CRT_SECURE_NO_WARNINGS<br /><br />#include&quot;LoadMemDll.h&quot;<br />#include&lt;fstream&gt;<br /><br />using&nbsp;namespace&nbsp;std;<br /><br /><br />typedef&nbsp;int(*PTestFunc)();<br /><br />int&nbsp;main()<br />{<br />	LoadMemDll&nbsp;loader;<br /><br />	string&nbsp;srcFilePath&nbsp;=&nbsp;&quot;dllPlain.dll&quot;;<br /><br />	fstream&nbsp;binary_file(srcFilePath,&nbsp;ios::binary&nbsp;|&nbsp;ios::in);<br />	<br />	binary_file.seekg(0,&nbsp;binary_file.end);<br />	DWORD&nbsp;dwSizeSrc&nbsp;=&nbsp;binary_file.tellg();//文件大小<br />	binary_file.seekg(0,&nbsp;binary_file.beg);<br /><br /><br />	char*&nbsp;szBuf&nbsp;=&nbsp;new&nbsp;char[dwSizeSrc];<br />	binary_file.read(szBuf,&nbsp;dwSizeSrc);<br />	binary_file.close();<br /><br />	//下面注释是dll内容亦或，用于免杀<br />	//for&nbsp;(DWORD&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;dwSizeSrc;&nbsp;i++)&nbsp;{<br />	//	szBuf[i]&nbsp;=&nbsp;szBuf[i]&nbsp;^&nbsp;1;<br />	//}<br /><br />	//fstream&nbsp;binary_outfile(&quot;encrypt.dat&quot;,&nbsp;ios::out&nbsp;|&nbsp;ios::binary&nbsp;|&nbsp;ios::app);<br />	//binary_outfile.write(szBuf,&nbsp;dwSizeSrc);<br />	//binary_outfile.close();<br /><br />	printf(&quot;Source&nbsp;file&nbsp;:[%s]&nbsp;size&nbsp;is&nbsp;:&nbsp;[%d]\n&quot;,&nbsp;srcFilePath.c_str(),&nbsp;dwSizeSrc);<br /><br />	PBYTE&nbsp;pMemDllbuf;<br />	if&nbsp;(!loader.LoadDll((PBYTE)szBuf,&nbsp;dwSizeSrc,&nbsp;(LPVOID&nbsp;*)&amp;pMemDllbuf))<br />	{<br />		OutputDebugStringA(&quot;LoadDll&nbsp;err&quot;);<br />		return&nbsp;-1;<br />	}<br /><br />	PTestFunc&nbsp;TestFunc&nbsp;=&nbsp;(PTestFunc)loader.GetMemProcAddress(pMemDllbuf,&nbsp;&quot;message&quot;);<br />	TestFunc();<br /><br />	return&nbsp;0;<br />}</div></div><br /><br />LoadMemDll.h<br /><div class="codebox"><div class="codebox">#pragma&nbsp;once<br />#define&nbsp;_CRT_SECURE_NO_WARNINGS<br />#include&lt;Windows.h&gt;<br />#include&lt;stdio.h&gt;<br />#define&nbsp;POINTER_TYPE&nbsp;DWORD<br />#define&nbsp;IMAGE_SIZEOF_BASE_RELOCATION&nbsp;(sizeof(IMAGE_BASE_RELOCATION))<br /><br />class&nbsp;LoadMemDll<br />{<br />public:<br />	bool&nbsp;LoadDll(PBYTE&nbsp;lpBuf,&nbsp;DWORD&nbsp;dwSize,&nbsp;OUT&nbsp;LPVOID*&nbsp;pMemDll);<br />	PBYTE&nbsp;GetRsrcDll(int&nbsp;nIdRsrc,&nbsp;TCHAR&nbsp;*szTypeRsrc,&nbsp;OUT&nbsp;DWORD&nbsp;*dwSize);<br />	DWORD&nbsp;GetMemProcAddress(PBYTE&nbsp;pMemDll,&nbsp;TCHAR&nbsp;*szFuncName);<br /><br />private:<br />	PIMAGE_DOS_HEADER&nbsp;m_pDosHeader;<br />	PIMAGE_NT_HEADERS&nbsp;m_pNtHeader;<br /><br />private:<br />	bool&nbsp;CheckIsAviliableDll(PBYTE&nbsp;pBuf);<br />	DWORD&nbsp;AlignSection(DWORD&nbsp;dwSize,&nbsp;DWORD&nbsp;Align);<br />	DWORD&nbsp;AlignFile(DWORD&nbsp;dwSize,&nbsp;DWORD&nbsp;Align);<br />	void&nbsp;FixReloc(PBYTE&nbsp;pMemBuf);<br />	bool&nbsp;FixImportTable(PBYTE&nbsp;pMemBuf);<br />};<br /></div></div><br /><br />LoadMemDll.cpp<br /><div class="codebox"><div class="codebox">#include&nbsp;&quot;LoadMemDll.h&quot;<br /><br />typedef&nbsp;&nbsp;&nbsp;BOOL(__stdcall&nbsp;*ProcDllMain)(HINSTANCE,&nbsp;DWORD,&nbsp;LPVOID);<br />bool&nbsp;LoadMemDll::LoadDll(PBYTE&nbsp;lpBuf,DWORD&nbsp;dwSize,&nbsp;OUT&nbsp;LPVOID*&nbsp;pMemDll)<br />{<br />	LPBYTE&nbsp;pAllocMemDll&nbsp;=&nbsp;NULL;<br />	*pMemDll&nbsp;=&nbsp;NULL;				//Init&nbsp;outptr&nbsp;nullptr<br />	if&nbsp;(!CheckIsAviliableDll(lpBuf))<br />		return&nbsp;false;<br /><br />	m_pDosHeader&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)lpBuf;<br />	m_pNtHeader&nbsp;=&nbsp;(PIMAGE_NT_HEADERS)(lpBuf&nbsp;+&nbsp;m_pDosHeader-&gt;e_lfanew);<br /><br />	PIMAGE_SECTION_HEADER&nbsp;pSecHeader&nbsp;=&nbsp;IMAGE_FIRST_SECTION(m_pNtHeader);<br />	DWORD&nbsp;dwSecAlign&nbsp;=&nbsp;m_pNtHeader-&gt;OptionalHeader.SectionAlignment;<br />	DWORD&nbsp;dwFileAlign&nbsp;=&nbsp;m_pNtHeader-&gt;OptionalHeader.FileAlignment;<br /><br />	pAllocMemDll&nbsp;=&nbsp;(LPBYTE)VirtualAlloc(NULL,&nbsp;m_pNtHeader-&gt;OptionalHeader.SizeOfImage,&nbsp;MEM_COMMIT&nbsp;|&nbsp;MEM_RESERVE,&nbsp;PAGE_EXECUTE_READWRITE);<br />	if&nbsp;(pAllocMemDll&nbsp;==&nbsp;NULL)<br />		return&nbsp;false;<br />	ZeroMemory(pAllocMemDll,&nbsp;m_pNtHeader-&gt;OptionalHeader.SizeOfImage);<br /><br />	//copy&nbsp;header&nbsp;to&nbsp;alloc&nbsp;mem<br />	DWORD&nbsp;dwHeaderSize&nbsp;=&nbsp;m_pNtHeader-&gt;OptionalHeader.SizeOfHeaders;<br />	memmove(pAllocMemDll,lpBuf,dwHeaderSize);						<br /><br />	//循环加载每一个节区<br />	while&nbsp;(pSecHeader-&gt;VirtualAddress&nbsp;&amp;&amp;&nbsp;pSecHeader-&gt;SizeOfRawData)		<br />	{<br />		DWORD&nbsp;dwSecImageSize&nbsp;=&nbsp;AlignSection(pSecHeader-&gt;Misc.VirtualSize,dwSecAlign);<br />		DWORD&nbsp;dwSecFileSize&nbsp;=&nbsp;pSecHeader-&gt;SizeOfRawData;<br />		DWORD&nbsp;dwRealSize&nbsp;=&nbsp;dwSecImageSize&nbsp;&gt;&nbsp;dwSecFileSize&nbsp;?&nbsp;dwSecFileSize&nbsp;:&nbsp;dwSecImageSize;<br />		memmove(pSecHeader-&gt;VirtualAddress&nbsp;+&nbsp;pAllocMemDll,pSecHeader-&gt;PointerToRawData&nbsp;+&nbsp;lpBuf,&nbsp;dwRealSize);<br /><br />		//next&nbsp;section<br />		pSecHeader&nbsp;=&nbsp;(PIMAGE_SECTION_HEADER)((PBYTE)pSecHeader&nbsp;+&nbsp;sizeof(IMAGE_SECTION_HEADER));<br />	}<br /><br />	FixReloc(pAllocMemDll);<br /><br />	if&nbsp;(!FixImportTable(pAllocMemDll))<br />		return&nbsp;false;<br /><br />	//启动DllMain<br />	ProcDllMain&nbsp;pDllMain&nbsp;=&nbsp;(ProcDllMain)(m_pNtHeader-&gt;OptionalHeader.AddressOfEntryPoint&nbsp;+&nbsp;pAllocMemDll);<br />	bool&nbsp;bStatus&nbsp;=&nbsp;pDllMain((HINSTANCE)pAllocMemDll,DLL_PROCESS_ATTACH,0);<br />	if&nbsp;(!bStatus)<br />	{<br />		pDllMain((HINSTANCE)pAllocMemDll,&nbsp;DLL_PROCESS_DETACH,&nbsp;0);<br />		VirtualFree(pAllocMemDll,&nbsp;0,MEM_RELEASE);<br />		return&nbsp;false;<br />	}<br /><br />	*pMemDll&nbsp;=&nbsp;pAllocMemDll;<br />	return&nbsp;true;<br />}<br /><br />PBYTE&nbsp;LoadMemDll::GetRsrcDll(int&nbsp;nIdRsrc,TCHAR&nbsp;*szTypeRsrc,OUT&nbsp;DWORD&nbsp;*dwSize)<br />{<br />	HRSRC&nbsp;hRsrc&nbsp;=&nbsp;FindResourceA(GetModuleHandleA(NULL),&nbsp;MAKEINTRESOURCE(nIdRsrc),&nbsp;szTypeRsrc);<br />	HGDIOBJ&nbsp;hGdi&nbsp;=&nbsp;LoadResource(GetModuleHandleA(NULL),hRsrc);<br />	PBYTE&nbsp;pBuf&nbsp;=&nbsp;(PBYTE)LockResource(hGdi);<br />	*dwSize&nbsp;=&nbsp;SizeofResource(GetModuleHandleA(NULL),hRsrc);<br />	return&nbsp;pBuf;<br />}<br /><br />DWORD&nbsp;LoadMemDll::GetMemProcAddress(PBYTE&nbsp;pMemDll,&nbsp;TCHAR&nbsp;*&nbsp;szFuncName)<br />{<br />	PIMAGE_EXPORT_DIRECTORY&nbsp;pExportDirectory&nbsp;=&nbsp;(PIMAGE_EXPORT_DIRECTORY)(m_pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress&nbsp;+&nbsp;pMemDll);<br />	PDWORD&nbsp;pAddressOfNamesTable&nbsp;=&nbsp;&nbsp;(PDWORD)(pExportDirectory-&gt;AddressOfNames&nbsp;+&nbsp;pMemDll);<br />	PWORD&nbsp;pAddressOfOridinalTable&nbsp;=&nbsp;(PWORD)(pExportDirectory-&gt;AddressOfNameOrdinals&nbsp;+&nbsp;pMemDll);<br /><br />	if&nbsp;(IsBadReadPtr(szFuncName,&nbsp;1))			//序号<br />	{<br />		WORD&nbsp;Base&nbsp;=&nbsp;pExportDirectory-&gt;Base;<br />		WORD&nbsp;index&nbsp;=&nbsp;(WORD)szFuncName&nbsp;-&nbsp;Base;<br />		if&nbsp;(index&nbsp;&gt;=&nbsp;pExportDirectory-&gt;NumberOfFunctions)<br />			return&nbsp;0;<br />		return&nbsp;*(PWORD)((PDWORD)(pExportDirectory-&gt;AddressOfFunctions&nbsp;+&nbsp;pMemDll)+&nbsp;index)&nbsp;+&nbsp;(DWORD)pMemDll;<br />	}<br />	else<br />	{<br />		for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;pExportDirectory-&gt;NumberOfNames;&nbsp;i++)<br />		{<br />			if&nbsp;(strcmp(szFuncName,&nbsp;(char&nbsp;*)(*(pAddressOfNamesTable&nbsp;+&nbsp;i)&nbsp;+&nbsp;pMemDll))&nbsp;==&nbsp;0)<br />			{<br />				WORD&nbsp;index&nbsp;=&nbsp;*(pAddressOfOridinalTable&nbsp;+&nbsp;i);<br />				return&nbsp;*(PWORD)((PDWORD)(pExportDirectory-&gt;AddressOfFunctions&nbsp;+&nbsp;pMemDll)&nbsp;+&nbsp;index)&nbsp;+&nbsp;(DWORD)pMemDll;<br />			}<br />		}<br />	}<br />	return&nbsp;0;<br />}<br /><br />bool&nbsp;LoadMemDll::CheckIsAviliableDll(PBYTE&nbsp;pBuf)<br />{<br />	PIMAGE_DOS_HEADER&nbsp;pDosHeader&nbsp;=&nbsp;(PIMAGE_DOS_HEADER)pBuf;<br />	PIMAGE_NT_HEADERS32&nbsp;pNtHeader&nbsp;=&nbsp;(PIMAGE_NT_HEADERS32)(pDosHeader-&gt;e_lfanew&nbsp;+&nbsp;pBuf);<br />	<br />	if&nbsp;(pDosHeader-&gt;e_magic&nbsp;==&nbsp;IMAGE_DOS_SIGNATURE)<br />	{<br />		if&nbsp;(pNtHeader-&gt;Signature&nbsp;==&nbsp;IMAGE_NT_SIGNATURE)<br />		{<br />			if&nbsp;(pNtHeader-&gt;FileHeader.Characteristics&nbsp;&amp;&nbsp;IMAGE_FILE_DLL)<br />			{<br />				return&nbsp;true;<br />			}<br />		}<br />	}<br />	return&nbsp;false;<br />}<br /><br />DWORD&nbsp;LoadMemDll::AlignSection(DWORD&nbsp;dwSize,&nbsp;DWORD&nbsp;Align)<br />{<br />	return&nbsp;((dwSize&nbsp;+&nbsp;Align&nbsp;-&nbsp;1)&nbsp;/&nbsp;Align&nbsp;*&nbsp;Align);<br />}<br /><br />DWORD&nbsp;LoadMemDll::AlignFile(DWORD&nbsp;dwSize,&nbsp;DWORD&nbsp;Align)<br />{<br />	return&nbsp;dwSize&nbsp;/&nbsp;Align&nbsp;*&nbsp;Align;<br />}<br /><br />void&nbsp;LoadMemDll::FixReloc(PBYTE&nbsp;pMemBuf)<br />{<br />	DWORD&nbsp;dwOriImage&nbsp;=&nbsp;m_pNtHeader-&gt;OptionalHeader.ImageBase;<br />	PIMAGE_BASE_RELOCATION&nbsp;pBaseReloc&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)(m_pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress&nbsp;+&nbsp;pMemBuf);<br />	int&nbsp;nSizeOfRelocDirectory&nbsp;=&nbsp;m_pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;<br />	int&nbsp;nNumOfRelocAddress;<br />	int&nbsp;nSzieOfRelocBlock;<br />	DWORD&nbsp;BaseRva;<br />	DWORD&nbsp;diff&nbsp;=&nbsp;(DWORD)pMemBuf&nbsp;-&nbsp;dwOriImage;<br /><br />	while&nbsp;(nSizeOfRelocDirectory)<br />	{<br />		nSzieOfRelocBlock&nbsp;=&nbsp;pBaseReloc-&gt;SizeOfBlock;<br />		if&nbsp;(nSzieOfRelocBlock&nbsp;==&nbsp;0)<br />			break;<br />		nNumOfRelocAddress&nbsp;=&nbsp;(nSzieOfRelocBlock&nbsp;-&nbsp;8)&nbsp;/&nbsp;2;<br />		BaseRva&nbsp;=&nbsp;pBaseReloc-&gt;VirtualAddress;<br />		WORD&nbsp;*pTypeOffset&nbsp;=&nbsp;(WORD&nbsp;*)((BYTE&nbsp;*)pBaseReloc&nbsp;+&nbsp;8);<br />		for&nbsp;(int&nbsp;nIndex&nbsp;=&nbsp;0;&nbsp;nIndex&nbsp;&lt;&nbsp;nNumOfRelocAddress&nbsp;;&nbsp;nIndex++)		<br />		{<br />			int&nbsp;type&nbsp;=&nbsp;pTypeOffset[nIndex]&nbsp;&gt;&gt;&nbsp;12;<br />			DWORD&nbsp;offset&nbsp;=&nbsp;pTypeOffset[nIndex]&nbsp;&amp;&nbsp;0x0FFF;<br />			switch&nbsp;(type)<br />			{<br />			case&nbsp;IMAGE_REL_BASED_ABSOLUTE:<br />				//什么都不用干<br />				break;<br />			case&nbsp;IMAGE_REL_BASED_HIGHLOW:<br />				*(PDWORD)(pMemBuf&nbsp;+&nbsp;offset&nbsp;+&nbsp;BaseRva)&nbsp;+=&nbsp;diff;<br />				break;<br />			default:<br />				break;<br />			}<br />		}<br />		nSizeOfRelocDirectory&nbsp;-=&nbsp;nSzieOfRelocBlock;<br />		pBaseReloc&nbsp;=&nbsp;(PIMAGE_BASE_RELOCATION)((PBYTE)pBaseReloc&nbsp;+&nbsp;nSzieOfRelocBlock);<br />	}<br />}<br /><br />bool&nbsp;LoadMemDll::FixImportTable(PBYTE&nbsp;pMemBuf)<br />{<br />	//IMAGE_ORDINAL_FLAG32<br />	PIMAGE_IMPORT_DESCRIPTOR&nbsp;pIID;<br />	pIID&nbsp;=&nbsp;(PIMAGE_IMPORT_DESCRIPTOR)(m_pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress&nbsp;+&nbsp;pMemBuf);<br /><br />	while(true)<br />	{<br />		if&nbsp;(pIID-&gt;Name&nbsp;==&nbsp;NULL)<br />			break;<br />		char&nbsp;szDllName[0x20];<br />		strcpy(szDllName,&nbsp;(char&nbsp;*)(pIID-&gt;Name&nbsp;+&nbsp;pMemBuf));<br /><br />		HMODULE&nbsp;hLibrary&nbsp;=&nbsp;LoadLibraryA(szDllName);<br />		if&nbsp;(!hLibrary)<br />		{<br />			char&nbsp;szInfo[0x30];<br />			sprintf(szInfo,&nbsp;&quot;未找到DLL%s&quot;,&nbsp;szDllName);<br />			//MessageBoxA(0,&nbsp;szInfo,&nbsp;0,&nbsp;0);<br />			return&nbsp;false;<br />		}<br /><br />		PIMAGE_THUNK_DATA32&nbsp;pIAT_Table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA32)(pIID-&gt;FirstThunk&nbsp;+&nbsp;pMemBuf);<br />		PIMAGE_THUNK_DATA32&nbsp;pINT_Table&nbsp;=&nbsp;(PIMAGE_THUNK_DATA32)(pIID-&gt;OriginalFirstThunk&nbsp;+&nbsp;pMemBuf);<br />		while&nbsp;(true)<br />		{<br />			PIMAGE_IMPORT_BY_NAME&nbsp;pImpotName&nbsp;=&nbsp;(PIMAGE_IMPORT_BY_NAME)(pINT_Table-&gt;u1.AddressOfData&nbsp;+&nbsp;pMemBuf);<br />			if&nbsp;(pINT_Table-&gt;u1.AddressOfData&nbsp;==&nbsp;NULL)<br />				break;<br />			if&nbsp;(pINT_Table-&gt;u1.AddressOfData&nbsp;&amp;&nbsp;IMAGE_ORDINAL_FLAG32)		//导出序号<br />			{<br />				pIAT_Table-&gt;u1.AddressOfData&nbsp;=&nbsp;(DWORD)GetProcAddress(hLibrary,&nbsp;(LPCSTR)((WORD)pINT_Table-&gt;u1.Ordinal));<br />			}<br />			else<br />			{<br />				pIAT_Table-&gt;u1.AddressOfData&nbsp;=&nbsp;(DWORD)GetProcAddress(hLibrary,&nbsp;(LPCSTR)pImpotName-&gt;Name);<br />			}<br /><br />			pINT_Table++;<br />			pIAT_Table++;<br />		}<br /><br />		pIID++;<br />	}<br />	return&nbsp;true;<br />}<br /><br /></div></div><p align="center"><img src="images\home.svg" height="22" width="22">  <a href="index.html">索引</a></p></div></body></html>