<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>隐藏注册表值</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>隐藏注册表值</h1><br/>隐藏注册表<br /><a href="https://mp.weixin.qq.com/s/8tWDKLmb5XEa-HhYlgnBgw">https://mp.weixin.qq.com/s/8tWDKLmb5XEa-HhYlgnBgw</a><br /><br />注册表键值名称经过特殊构造： 以”\0”作为开头，后面加上任意字符(不能为数字)<br />对于Windows系统，”\0”(即0x0000)会被识别为字符串的结束符，所以在对该字符串读取的过程中，遇到开头的”\0”，会被解析成结束符，提前截断，导致读取错误<br />而使用Native API设定注册表，需要使用结构体OBJECT_ATTRIBUTES作为参数， 指定读取的字符串长度<br />只要长度设定正常，就能够读取正确的字符串，避免这个bug<br />所以，我们可以通过Native API来创建这个特殊的注册表名<br />更为重要的是，像regedit.exe和其他对注册表的操作，通常会调用Win32 API，这就导致该注册表无法被读取，也就实现了所谓的”隐藏”<br />综上，创建方法为： 通过Native API创建一个以”\0”开头的键值<br /><br /><br /><strong>0x03 编写程序实现</strong><br />通过Native API实现对注册表的操作，可供参考的工程地址：<br />https://www.codeproject.com/Articles/14508/Registry-Manipulation-Using-NT-Native-APIs<br />作者Dan Madden，他的代码使用了类的封装<br />个人倾向于使用最基本的api实现，于是参考他的代码，重新设计<br />对于Native API，需要的结构如下：<br />1.获取Native API的地址<br />注册表操作的相关Native API可从ntdll.dll中获得<br />关键代码如下：<br /><span style="color:#7f7f7f;">     HINSTANCE hinstStub = GetModuleHandle(_T(&quot;ntdll.dll&quot;));NtOpenKey = (LPNTOPENKEY)GetProcAddress(hinstStub, &quot;NtOpenKey&quot;);</span><br />2.Native API的重定义和声明<br />Native API在使用前需要重定义和声明<br />部分关键代码如下：<br /><span style="color:#7f7f7f;">     typedef NTSTATUS (STDAPICALLTYPE NTOPENKEY)(    IN HANDLE                KeyHandle,    IN ULONG                DesiredAccess,    IN  POBJECT_ATTRIBUTES   ObjectAttributes);typedef NTOPENKEY FAR *  LPNTOPENKEY;LPNTOPENKEY                 NtOpenKey;</span><br /> 3. 特殊结构体的使用<br />注册表操作相关Native API会使用到如下结构体，需要定义和声明<br /><span style="color:#7f7f7f;">      ·InitializeObjectAttributes·_STRING·_UNICODE_STRING·_OBJECT_ATTRIBUTES·_KEY_INFORMATION_CLASS·_KEY_BASIC_INFORMATION·_KEY_VALUE_PARTIAL_INFORMATION·_KEY_VALUE_INFORMATION_CLASS··RtlInitAnsiString·RtlAnsiStringToUnicodeString</span><br />Dan Madden的工程实现了创建隐藏注册表项(注册表项名称以\0开头)，该注册表项下的键值通过正常的Native API实现创建、读取、删除<br />通过最基本api的实现过程不再赘述，封装好的API源代码可参考文末给出的链接<br />测试Dan Madden工程包含的功能：<br />1.创建隐藏注册表项<br /><span style="color:#7f7f7f;">     MyCreateHiddenKey(&quot;\\Registry\\Machine\\Software\\testhidden&quot;);</span><br />使用注册表工具regedit.exe无法打开该键值，如下图<br /><a href=""><img src="images\246-1.png" alt="images\246-1.png" /></a><br />2.在该注册表下创建注册表键值<br />先获得该注册表项的句柄：<br /><span style="color:#7f7f7f;">     hKey = MyOpenHiddenKey(&quot;\\Registry\\Machine\\Software\\testhidden&quot;);</span><br />创建注册表项下的键值test1并赋值：<br /><span style="color:#7f7f7f;">     MySetValueKey(hKey,&quot;test1&quot;,&quot;0123456789abcdef&quot;,REG_SZ);</span><br />读取该注册表项下键值test1的内容：<br /><span style="color:#7f7f7f;">     MyQueryValueKeyString(hKey,&quot;test1&quot;);</span><br />删除该注册表项下的键值test1：<br /><span style="color:#7f7f7f;">     MyDeleteValueKey(hKey,&quot;test1&quot;);</span><br />删除注册表项：<br /><span style="color:#7f7f7f;">     MyDeleteKey(hKey);</span><br />程序输出如下图，成功对隐藏注册表项下的正常键值进行操作<br /><a href=""><img src="images\246-2.png" alt="images\246-2.png" /></a><br />接下来，对Dan Madden的工程添加新的功能：创建、读取、删除隐藏注册表键值，思路如下：<br /><br />对于注册表项的隐藏，在注册表项的名称首位填”\0”即可<br />对应注册表键值的隐藏，原理上也是在键值的名称首位填”\0”，但在参数传递上需要注意更多问题<br />1.不需要修改的功能<br />创建注册表键、打开注册表键和删除注册表键的功能不需要修改，使用正常的名称即可<br />2.设置注册表键值<br />对应源代码中的MySetHiddenValueKey<br />传入参数使用char型数组，，用来定义注册表键值名称，内容为”\0abcd”<br />由于”\0”的存在，所以无法直接使用strlen计算数组长度<br />变通方法：<br />计算从偏移1开始的数组长度，最终再加1<br />即len = strlen(buf+1)+1<br />Native API NtSetValueKey用来设定键值，定义如下：<br /><span style="color:#7f7f7f;">     typedef NTSTATUS (STDAPICALLTYPE NTSETVALUEKEY)(    IN HANDLE            KeyHandle,    IN PUNICODE_STRING  ValueName,    IN ULONG             TitleIndex,         /* optional */    IN ULONG            Type,    IN  PVOID            Data,    IN ULONG            DataSize);</span><br />第二个参数指定键值名称，需要使用结构体UNICODE_STRING<br />正常情况下，我们需要先使用RtlInitAnsiString将传入的buf数组转换成结构体ANSI_STRING，再使用RtlAnsiStringToUnicodeString将其转换成结构体UNICODE_STRING，作为参数<br />由于”\0”的存在，无法使用RtlAnsiStringToUnicodeString<br />所以，我们需要自己实现结构体ANSI_STRING向结构体UNICODE_STRING的转换<br />ANSI向UNICODE的转换，在长度计算上，乘以2即可<br />数组内容上，奇数位赋值，偶数为填0x00<br />当然，我们需要一个中转数组TempBuff实现数组内容的转换<br />关键代码如下：<br /><span style="color:#7f7f7f;">     ValueName.Length = asName.Length*2;ValueName.MaximumLength =  asName.MaximumLength*2;char *TempBuff;TempBuff =  (char*)malloc(ValueName.Length);for(int i=0;i&lt;asName.Length;i++){     TempBuff[i*2] = asName.Buffer[i];    TempBuff[i*2+1] =  0x00;}ValueName.Buffer = (WCHAR *)TempBuff;</span><br />第四个参数，指定键值内容，需要将传入的char数组转换为WCHAR<br />关键代码：<br /><span style="color:#7f7f7f;">     WCHAR wszValue[1024];unsigned int n ;for (n=0; n&lt;strlen(csData);  n++) {    wszValue[n] = (WCHAR)csData[n];}wszValue[n++] = L&#39;\0&#39;;</span><br /><br />3.读取注册表键值<br />对应源代码中的MyQueryHiddenValueKeyString<br />参照2，需要注意”\0”的影响<br />4、删除注册表键值<br />对应源代码中的MyDeleteHiddenValueKey<br />参照2，需要注意”\0”的影响<br />实际测试：<br />创建注册表项test2,创建隐藏注册表键值\0test2,创建正常注册表键值test2<br />直接打开，如下图<br /><a href=""><img src="images\246-3.png" alt="images\246-3.png" /></a><br />能够正常访问注册表键值test2，但无法访问注册表键值\0test2<br />如下图<br /><a href=""><img src="images\246-4.png" alt="images\246-4.png" /></a><br />而我们编写的程序能够正常读取，如下图<br /><a href=""><img src="images\246-5.png" alt="images\246-5.png" /></a><br />至此，成功实现对注册表键值的隐藏<br />以上功能代码已开源，地址如下：<br />https://github.com/3gstudent/HiddenNtRegistry<br /><a href=""><img src="images\246-6.png" alt="images\246-6.png" /></a> <strong>0x04 powershell实现</strong><br />可参考Brian Reitz的工程，地址如下：<br />https://gist.github.com/brianreitz/feb4e14bd45dd2e4394c225b17df5741<br />具体说明可参考：<br />https://posts.specterops.io/hiding-registry-keys-with-psreflect-b18ec5ac8353?source=collection_archive———2—————-<br />实现了在HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run下创建键值\0abcd，内容为mshta javascript:alert(1)<br />使用我们编写的程序成功读取该键值，如下图<br /><a href=""><img src="images\246-7.png" alt="images\246-7.png" /></a><br /><a href=""><img src="images\246-8.png" alt="images\246-8.png" /></a> <strong>0x05 补充</strong><br />PSReflect-Functions包含多个通过powershell调用API的实例代码，地址如下：<br />https://github.com/jaredcatkinson/PSReflect-Functions<br /><p align="center"><img src="images\home.svg" height="22" width="22">  <a href="index.html">索引</a></p></div></body></html>